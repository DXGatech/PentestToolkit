module WifiTool
module Network
module Servers

class DnsWrapper < RubyDNS::RuleBasedServer
    attr_accessor :rules 

    @@instance = nil

    def self.get
        @@instance
    end

    def initialize(options = {}, &block)
        super(options, &block)
        @rules = []
        @@instance = self
    end

    def process(name, resource_class, transaction)
        Logger.debug "[#{'DNS'.green}] Received #{resource_class.name} request for #{name}"
        super
    end
end

class DNSD
    def initialize(host_filename = nil, address = '0.0.0.0', port = 5300)
        @port = port
        @address = address
        @hosts = hosts_filename
        @server = nil
        @ifaces = [
            [:udp, address, port],
            [:tcp, address, port]
        ]
    end

    def self.parse_hosts(filename)
        raise BetterCap::Error, "File '#{filename}' does not exist" unless File.exist?(filename)
        hosts = {}
        File.open(filename).each_with_index do |line, lineno|
            line = line.strip
            next if line.empty? or line[0] == '#'
            if line =~ /^([^\s]+)(\s+)(.+)$/
                address = $1
                expression = $2
                if address == 'local'
                    address = Context.get.iface.ip.to_s
                end

                raise WifiTool::Error, "invalid ipv4 address '#{address}' on line #{lineno + 1} in '#{filename}'" unless Network::Validator.is_ip?(address)
                begin
                    hosts[expression] = address
                rescue RegexpError
                    raise WifiTool::Error, "'#{expression}' on line '#{lineno}' in '#{filename}' is invalid"
                end
            end
        end
        hosts
    end

    def add_rule!(exp, addr)
        Logger.debug "[#{'DNS'.green}] new rule: '#{exp}' -> '#{addr}' "
        block = Proc.new do |transaction|
            Logger.info "[#{transaction.options[:peer]} > #{'DNS'.green}] sent a request for '#{transaction.question.to_s.yellow}', spoofing to #{addr.yellow}"
            begin
                transaction.respond!(addr)
            rescue Exception => e 
                Logger.warn "[#{'DNS'.green}] #{e.message}"
                Logger.exception e 
            end
        end
        DnsWrapper.get.rules << RubyDNS::RuleBasedServer::Rule.new([Regexp.new(exp), Resolv::DNS::Resource::IN::A], block)
    end

    def start
        Logger.info "[#{'DNS'.green}] server started: #{@address}:#{@port}"
        options = {
            :listen => @ifaces,
            :asynchronous => true,
            :server_class => DnsWrapper
        }

        begin
            RubyDNS::run_server(options) do
                @logger.level = ::Logger::Error
                @upstream ||= RubyDNS::Resolver.new([[:udp, "8.8.8.8", 53], [:tcp, "8.8.8.8", 53]]) # used to pass user request to default local DNS server		
		        # Specify a default block to execute if all other rules fail to match. This block is typially used to pass the request on to another server (i.e. recursive request).
		        #
		        #	otherwise do |transaction|
		        #		transaction.passthrough!($R)
		        #	end
		        #
                otherwise do |transaction|
                    Logger.debug "[#{transaction.options[:peer]} > #{'DNS'.green}] sent a request for '#{transaction.question.to_s.yellow}' -> upstream DNS" 
                    transaction.passthrough!(@upstream)
                end
            end

            unless @hosts.nil?
                DNSD.parse_hosts(@hosts).each do |exp, addr|
                    add_rule!(exp, addr) # spoofs listed hosts within the file with DNS response
                end
            end
        rescue Errno::EADDRINUSE
            raise WifiTool::Error, "[DNS] another process is using #{@address}:#{@port}"
        end
    end

    def stop; end

end

end
end
end

    
